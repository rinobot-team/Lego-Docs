{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Sum\u00f4 Lego - Documenta\u00e7\u00e3o","text":""},{"location":"#sobre","title":"Sobre","text":"<p>Este site tem como objetivo documentar o codebase da categoria Sum\u00f4 Lego da equipe de rob\u00f3tica Rinobot. Ele est\u00e1 sob a licen\u00e7a MIT, que pode ser encontrada aqui.  </p> <p>Todas as pastas abordam um t\u00f3pico espec\u00edfico do codebase, e cont\u00e9m um arquivo <code>index.md</code> de \u00edndice.  </p> <p>\u00c9 uma boa pr\u00e1tica que todos membros da categoria leiam deste documento para entender o funcionamento do codebase, assim como atualizar este documento conforme novas atualiza\u00e7\u00f5es forem sendo atualizados.</p> <p>Qualquer duvida sobre o funcionamento do codebase pode ser tirada com os membros, coordenadores ou gerente da categoria. Ou tamb\u00e9m, deixando uma issue no reposit\u00f3rio oficial caso seja membro da equipe.</p>"},{"location":"#indice-e-status","title":"\u00cdndice e Status","text":"T\u00f3pico Status Configura\u00e7\u00e3o do Projeto Incompleto Framework N\u00e3o Existe Rob\u00f4s N\u00e3o Existe Migra\u00e7\u00e3o para EV3 N\u00e3o Existe Workflow N\u00e3o Existe <p>Documenta\u00e7\u00e3o baseada na lind\u00edssima SPL-Docs!</p>"},{"location":"config-projeto/","title":"Configura\u00e7\u00e3o de Projeto","text":"<p>Para come\u00e7ar a desenvolver na categoria Sum\u00f4 Lego s\u00e3o necess\u00e1rios alguns passos para configurar seu ambiente.</p> <p>O passo a passo pode ser encontrado nestes documentos:</p> <ul> <li>Configura\u00e7\u00e3o do Git </li> <li>Configura\u00e7\u00e3o da IDE </li> <li>Setup NXT </li> <li>Setup EV3 </li> <li>Documenta\u00e7\u00e3o </li> </ul>"},{"location":"config-projeto/config-git/","title":"Configurando o Git","text":"<p>Caso voc\u00ea n\u00e3o tenha configurado seu Git ainda.</p>"},{"location":"config-projeto/config-git/#configurando-username-e-email","title":"Configurando Username e Email","text":"<p>A primeira coisa que voc\u00ea deve fazer ao instalar o Git \u00e9 configurar seu nome de usu\u00e1rio e email. Isso \u00e9 importante para que o Git saiba quem est\u00e1 fazendo as altera\u00e7\u00f5es no c\u00f3digo ao gerar o commit.</p> <p><pre><code>git config --global user.name \"Seu Nome\"\ngit config --global user.email \"Seu Email\"\n</code></pre> Ideal que utilize seu email institucional ou o fornecido \u00e0 Rinobot.</p>"},{"location":"config-projeto/config-git/#criando-e-adicionando-a-ssh-key","title":"Criando e adicionando a SSH-Key","text":"<p>Desde 2023, o Github n\u00e3o aceita mais autentica\u00e7\u00e3o por senha, ent\u00e3o \u00e9 necess\u00e1rio criar uma chave SSH (Secure Shell Protocol) para autentica\u00e7\u00e3o. Voc\u00ea pode seguir o tutorial oficial do Github aqui. Caso j\u00e1 tenha essa parte configurada, voc\u00ea pode pular para o pr\u00f3ximo passo. Qualquer d\u00favida, entre em contato com a equipe.</p>"},{"location":"config-projeto/config-ide/","title":"Configura\u00e7\u00e3o das IDEs","text":""},{"location":"config-projeto/config-ide/#todo-setup-do-robotc","title":"TODO: Setup do RobotC","text":""},{"location":"config-projeto/config-ide/#todo-setup-vscode","title":"TODO: Setup VSCode","text":""},{"location":"config-projeto/documentacao/","title":"Documenta\u00e7\u00e3o","text":"<p>Este documento visa descrever como documentar corretamente o projeto e o workflow de desenvolvimento. Assim como um resumo de produ\u00e7\u00e3o com Markdown e configura\u00e7\u00f5es do projeto e gera\u00e7\u00e3o do site.</p> <p>Qualquer d\u00favida, problema na configura\u00e7\u00e3o, corre\u00e7\u00e3o ou sugest\u00e3o de melhoria, entre em contato com o gerente da categoria ou abra uma issue no reposit\u00f3rio.</p>"},{"location":"config-projeto/documentacao/#markdown","title":"Markdown","text":"<p>Markdown \u00e9 uma linguagem de marca\u00e7\u00e3o que permite a escrita de textos com formata\u00e7\u00e3o simples e r\u00e1pida. \u00c9 amplamente utilizada em documenta\u00e7\u00f5es de projetos, READMEs, wikis, entre outros. A linguagem \u00e9 simples e f\u00e1cil de aprender, e permite a escrita de textos com formata\u00e7\u00e3o b\u00e1sica, como t\u00edtulos, listas, links, imagens, tabelas, entre outros:</p> <p><pre><code># Titulo 1\n## Titulo 2\n### Titulo 3\n\nnegrito: **negrito**\nit\u00e1lico: *it\u00e1lico*\n\nlinha de c\u00f3digo: `c\u00f3digo`\nbloco de c\u00f3digo:\n    ```rust\n    fn main() {\n        println!(\"Hello, lego!\");\n    }\n    ```\n\u00c9 poss\u00edvel escolher a linguagem para melhor formata\u00e7\u00e3o do bloco de c\u00f3digo.\n\nCita\u00e7\u00e3o ou coment\u00e1rio: &gt; Coment\u00e1rio muito foda!\n\nLista n\u00e3o ordenada:\n- item 1\n- item 2\n- item 3\n\nLista ordenada:\n1. item 1\n2. item 2\n3. item 3\n\nLink: [Colinha de markdown](https://www.markdownguide.org/cheat-sheet/)\n</code></pre> Algumas conven\u00e7\u00f5es de formata\u00e7\u00e3o de texto s\u00e3o:    </p> <ul> <li>Utilizar somente um <code># Titulo</code> por arquivo.  </li> <li>Adicionar dois espa\u00e7os no final de uma linha para quebra de linha.  </li> <li>Utilizar <code>---</code> para separar se\u00e7\u00f5es, ou assuntos diferentes.  </li> <li>Comandos ou estruturas de diret\u00f3rios devem ser escritos como <code>c\u00f3digo</code>.  </li> <li>Separar texto de t\u00f3picos com uma linha em branco.  </li> </ul> <p>Informa\u00e7\u00f5es mais detalhadas sobre a linguagem Markdown podem ser encontradas no Cheat-Sheet.  </p>"},{"location":"config-projeto/documentacao/#configuracao","title":"Configura\u00e7\u00e3o","text":""},{"location":"config-projeto/documentacao/#git","title":"Git","text":"<p>\u00c9 ideal que os reposit\u00f3rios sejam clonados por SSH, j\u00e1 tendo a chave SSH configurada no GitHub, como feito anteriomente. Isso facilita o processo de clonagem e push de arquivos.</p> <p><pre><code>    git clone git@github.com:rinobot-team/Lego-Docs.git\n</code></pre> Caso haja algum problema de permiss\u00e3o entre em contato com o gerente da categoria ou diretor de projetos.</p> <p>O reposit\u00f3rio \u00e9 dividido em 3 branchs principais: - <code>main</code>: branch principal, onde o c\u00f3digo est\u00e1vel \u00e9 mantido. - <code>dev</code>: branch de desenvolvimento, onde as novas documenta\u00e7\u00f5es s\u00e3o escritas e revisadas. - <code>gh-pages</code>: branch de produ\u00e7\u00e3o, onde a documenta\u00e7\u00e3o \u00e9 publicada.  </p> <p>O ideal \u00e9 que cada desenvolvedor crie uma branch local para desenvolver suas documenta\u00e7\u00f5es, e depois fa\u00e7a um pull request para a branch <code>dev</code>. Assim, as documenta\u00e7\u00f5es podem ser revisadas e corrigidas antes de serem publicadas.</p> <p><pre><code>    git branch sua-branch\n    # Depois de fazer as altera\u00e7\u00f5es e commits\n    git switch dev\n    git merge sua-branch\n    git push\n</code></pre> Cuidado para n\u00e3o dar push na sua branch local</p> <p>Caso seu documento seja revisado e aprovado, ele ser\u00e1 movido para a branch <code>main</code> e <code>gh-pages</code> para ser publicado. Caso seu documento seja revisado e aprovado, ele ser\u00e1 movido para a branch <code>main</code> e <code>gh-pages</code> para ser publicado.</p> <p><pre><code>    git switch main\n    git switch main\n    git merge dev\n    git push\n</code></pre> Merge entre dev e main \u00e9 idealmente feita pelo gerente, mas pode ser feita por qualquer membro da equipe mediante aprova\u00e7\u00e3o.</p>"},{"location":"config-projeto/documentacao/#mkdocs","title":"MkDocs","text":"<p>O MkDocs \u00e9 uma ferramenta que permite a cria\u00e7\u00e3o de documenta\u00e7\u00f5es est\u00e1ticas a partir de arquivos Markdown. Ele \u00e9 utilizado para gerar a documenta\u00e7\u00e3o do projeto e public\u00e1-la no GitHub Pages. Como esse projeto \u00e9 baseado em python, \u00e9 necess\u00e1rio criar um ambiente virtual para instalar as depend\u00eancias.</p> <pre><code>    python3 -m venv venv\n    source venv/bin/activate\n    pip install -r requirements.txt\n</code></pre> <p>Caso o m\u00e9todo anterior n\u00e3o funcione (se o tema n\u00e3o for encontrado ao utilizar <code>mkdocs serve</code>), voc\u00ea pode instalar o MkDocs e o MkDocs Material usando o <code>pip</code> diretamente, mas n\u00e3o \u00e9 recomendado:</p> <p><pre><code>    pip install --break-system-packages mkdocs mkdocs-material\n</code></pre> Com isso voc\u00ea j\u00e1 deve ter tudo necess\u00e1rio para documentar.</p>"},{"location":"config-projeto/documentacao/#workflow","title":"Workflow","text":""},{"location":"config-projeto/documentacao/#desenvolvimento","title":"Desenvolvimento","text":"<p>Para gerar o site de forma concisa e customizada h\u00e1 um arquivo <code>mkdocs.yml</code> que cont\u00e9m as configura\u00e7\u00f5es do site. Nele \u00e9 poss\u00edvel adicionar temas, plugins, e customizar a apar\u00eancia do site. A sintaxe \u00e9 simples e intuitiva, e a documenta\u00e7\u00e3o oficial do MkDocs pode te ajudar muito.</p> <p>Al\u00e9m disso, utilizamos o tema MkDocs Material, que \u00e9 um tema moderno e responsivo, com suporte a dark mode e muitas outras funcionalidades e plugins.</p> <p>Para testar o site localmente, basta rodar o comando:</p> <p><pre><code>    mkdocs serve\n</code></pre> e ele ir\u00e1 gerar um servidor local com o site, que pode ser acessado em <code>http://127.0.0.1:8000/</code>.</p> <p>Erros de sintaxe ou localiza\u00e7\u00e3o de arquivo s\u00e3o mostrados no terminal, e o site \u00e9 atualizado automaticamente a cada altera\u00e7\u00e3o feita nos arquivos Markdown ou estrutura do projeto.</p> <p>\u00c9 comum que ocorram erros em localiza\u00e7\u00e3o de imagens ou outros arquivos de asset, por isso optamos por mante-los no mesmo diret\u00f3rio que o arquivo Markdown que os utiliza.</p> <p>Al\u00e9m disso \u00e9 importante adicionar novos arquivos na se\u00e7\u00e3o <code>nav</code> do arquivo <code>mkdocs.yml</code>, para que eles sejam exibidos no mapa do site.</p>"},{"location":"config-projeto/documentacao/#deploy","title":"Deploy","text":"<p>Para publicar a documenta\u00e7\u00e3o no GitHub Pages, basta rodar o comando:</p> <p><pre><code>    mkdocs gh-deploy\n</code></pre> O comando acima \u00e9 utilizado para publicar a documenta\u00e7\u00e3o no GitHub Pages. Ele gera uma p\u00e1gina est\u00e1tica com a documenta\u00e7\u00e3o e a publica na branch <code>gh-pages</code> automaticamente. A p\u00e1gina pode ser acessada em <code>https://rinobot-team.github.io/Lego-Docs/</code>.</p> <p>\u00c9 de boa pr\u00e1tica que esse deploy seja feito ap\u00f3s a revis\u00e3o e aprova\u00e7\u00e3o da documenta\u00e7\u00e3o e somente na branch <code>main</code>, para evitar erros e problemas de visualiza\u00e7\u00e3o.</p>"},{"location":"config-projeto/setup-ev3/","title":"Setup do EV3","text":""},{"location":"config-projeto/setup-ev3/#cartao-sd","title":"Cart\u00e3o SD","text":"<p>O EV3 utiliza um cart\u00e3o SD para armazenar o sistema operacional e os arquivos do usu\u00e1rio. Para configurar o cart\u00e3o SD, siga os passos abaixo:</p> <ol> <li>Baixe a imagem do SO EV3DEV a partir do reposit\u00f3rio oficial.</li> <li>Use uma ferramenta como o Etcher para gravar a imagem no cart\u00e3o SD. Baixe at\u00e9 a vers\u00e3o 17 do Etcher, pois vers\u00f5es mais recentes podem apresentar problemas.</li> <li>Insira o cart\u00e3o SD no computador com um adaptador de cart\u00e3o SD, inicialize o Etcher, selecione a imagem baixada e o cart\u00e3o SD como destino, e clique em <code>Flash!</code> (Isso vai apagar todo o conte\u00fado do cart\u00e3o SD).</li> <li>Ap\u00f3s a grava\u00e7\u00e3o, insira o cart\u00e3o SD no EV3 e ligue o dispositivo. O EV3 deve iniciar com o sistema operacional EV3DEV.</li> </ol>"},{"location":"config-projeto/setup-ev3/#configuracao-de-rede-via-bluetooth","title":"Configura\u00e7\u00e3o de Rede via Bluetooth","text":"<p>Para conectar o EV3 a uma rede Wi-Fi, \u00e9 preciso conectar via bluetooth \u00e0 um computador ou smartphone e habilitar o bluetooth tethering:</p>"},{"location":"config-projeto/setup-ev3/#ubuntu-1604","title":"Ubuntu (16.04)","text":"<p>No PC na sala h\u00e1 uma maquina virtual com Ubuntu 16.04 pronta para uso.</p> <ol> <li>No EV3, v\u00e1 em <code>Brickman &gt; Wireless and Networks &gt; Bluetooth &gt; Visibile</code> e habilite a visibilidade.</li> <li>No computador, abra o Blueman e no menu <code>View &gt; Local Services</code> habilite a op\u00e7\u00e3o <code>Network Access Point</code> e a op\u00e7\u00e3o de <code>PAN</code> (Personal Area Network).</li> <li>No Blueman, clique em <code>Search</code> para procurar o EV3, depois clique em <code>Pair</code> (\u00edcone de chaves) para emparelhar o EV3 com o computador. Cliquei na estrela para salvar o EV3 como confi\u00e1vel.</li> <li>No EV3, aceite o emparelhamento e cheque o c\u00f3digo PIN (que aparece no computador).</li> <li>Agora, no EV3, voc\u00ea deve ter a op\u00e7\u00e3o <code>Connect to Network</code> habilitada no menu de Bluetooth. Clique nela para conectar o EV3 \u00e0 rede do computador.</li> <li>Se tudo der certo, o EV3 deve ter o estado de rede alterado para <code>Online</code>.</li> </ol>"},{"location":"config-projeto/setup-ev3/#android","title":"Android","text":"<ol> <li>No EV3, v\u00e1 em <code>Brickman &gt; Wireless and Networks &gt; Bluetooth &gt; Visibile</code> e habilite a visibilidade.</li> <li>No smartphone, ative o Bluetooth e emparelhe com o EV3.</li> <li>No smartphone, ative o <code>Bluetooth Tethering</code> (em <code>Configura\u00e7\u00f5es &gt; Rede e Internet &gt; Hotspot e tethering</code>, ou semelhante).</li> <li>Confirme o emparelhamento no EV3, checando o c\u00f3digo PIN.</li> <li>Agora, no EV3, voc\u00ea deve ter a op\u00e7\u00e3o <code>Connect to Network</code> habilitada no menu de Bluetooth. Clique nela para conectar o EV3 \u00e0 rede do smartphone.</li> <li>Se tudo der certo, o EV3 deve ter o estado de rede alterado para <code>Online</code>.</li> </ol> <p>Existe uma forma de conectar via windows, mas n\u00e3o conseguimos fazer funcionar durante os testes.</p>"},{"location":"config-projeto/setup-ev3/#configuracao-de-rede-via-cabo-usb","title":"Configura\u00e7\u00e3o de Rede via Cabo USB","text":"<p>Tamb\u00e9m \u00e9 poss\u00edvel conectar o EV3 \u00e0 rede via cabo USB. Esse \u00e9 o m\u00e9todo indicado para Windows 10, mas ainda n\u00e3o foi testado. Para isso, siga os passos abaixo:</p> <ol> <li>Conecte o EV3 ao computador usando um cabo USB.</li> <li>V\u00e1 em <code>Dispositivos e Impressoras</code> no Windows e localize o EV3, ele deve aparecer com o nome 'Remote NDIS Compatible Device'.</li> <li>Espere o Windows instalar os drivers necess\u00e1rios.</li> <li>Ap\u00f3s a instala\u00e7\u00e3o, clique com o bot\u00e3o direito no EV3 em <code>Dispositivos e Impressoras</code> e selecione <code>Configura\u00e7\u00f5es de Rede</code>.</li> <li>Veja qual tipo de acesso \u00e0 rede est\u00e1 dispon\u00edvel (geralmente <code>Internet - Network 5</code> ou semelhante).</li> <li>V\u00e1 em <code>Alterar as Configura\u00e7\u00f5es do Adaptador</code> no painel lateral esquerdo e Renomeie a conex\u00e3o do EV3 para algo f\u00e1cil de identificar, como <code>EV3 USB</code>.</li> <li>Para compartilhar a conex\u00e3o de internet do computador com o EV3, clique com o bot\u00e3o direito na conex\u00e3o de internet ativa (Wi-Fi ou Ethernet) e selecione <code>Propriedades</code>.</li> <li>V\u00e1 at\u00e9 a aba <code>Compartilhamento</code> e marque a op\u00e7\u00e3o <code>Permitir que outros usu\u00e1rios da rede se conectem pela conex\u00e3o deste computador \u00e0 Internet</code>.</li> <li>No menu suspenso abaixo, selecione a conex\u00e3o do EV3 que voc\u00ea renomeou anteriormente (<code>EV3 USB</code>).</li> <li>Clique em <code>OK</code> para salvar as configura\u00e7\u00f5es.</li> <li>No EV3, v\u00e1 em <code>Brickman &gt; Wireless and Networks &gt; USB</code> e selecione <code>Connect to Network</code>.</li> <li>Se tudo der certo, o EV3 deve ter o estado de rede alterado para <code>Online</code>.</li> </ol>"},{"location":"config-projeto/setup-ev3/#acesso-via-ssh","title":"Acesso via SSH","text":"<p>Ap\u00f3s conectar o EV3 \u00e0 rede, voc\u00ea pode acessar o dispositivo via SSH. O endere\u00e7o IP do EV3 pode ser encontrado no menu <code>Brickman &gt; Wireless and Networks &gt; Wi-Fi &gt; Status</code>.</p> <p>Use o seguinte comando no terminal do seu computador para acessar o EV3 via SSH:</p> <pre><code>ssh robot@&lt;IP_DO_EV3&gt;\n</code></pre> <p>Tamb\u00e9m \u00e9 poss\u00edvel enviar arquivos para o EV3 usando SCP:</p> <pre><code>scp &lt;ARQUIVO&gt; robot@&lt;IP_DO_EV3&gt;:/home/robot/\n</code></pre> <p>Para a primeira conex\u00e3o, a senha padr\u00e3o \u00e9 <code>maker</code>.</p>"},{"location":"config-projeto/setup-ev3/#rodando-um-programa","title":"Rodando um Programa","text":"<p>Para rodar um programa no EV3, voc\u00ea pode transferir o arquivo do programa para o EV3 via SCP e depois execut\u00e1-lo via SSH. Por exemplo:</p> <pre><code>scp meu_programa.py robot@&lt;IP_DO_EV3&gt;:/home/robot/\nssh robot@&lt;IP_DO_EV3&gt; 'python3 /home/robot/meu_programa.py'\n</code></pre> <p>Para programas C/C++, \u00e9 aconselh\u00e1vel compilar no computador host e transferir o bin\u00e1rio para o EV3, garantindo que todas as depend\u00eancias estejam satisfeitas:</p> <pre><code>scp meu_programa robot@&lt;IP_DO_EV3&gt;:/home/robot/\nssh robot@&lt;IP_DO_EV3&gt; '/home/robot/meu_programa'\n</code></pre> <p>Tamb\u00e9m \u00e9 poss\u00edvel rodar programas pela interface do Brickman, navegando at\u00e9 o arquivo do programa e selecionando-o para execu\u00e7\u00e3o.</p>"},{"location":"config-projeto/setup-nxt/","title":"Setup NXT","text":""},{"location":"config-projeto/setup-nxt/#todo-como-configurar-o-nxt-para-receber-nosso-codigo","title":"TODO: Como configurar o NXT para receber nosso c\u00f3digo?","text":""},{"location":"migracao-ev3/","title":"Migra\u00e7\u00e3o para o EV3","text":"<p>Esta se\u00e7\u00e3o aborda o processo de migra\u00e7\u00e3o do c\u00f3digo e configura\u00e7\u00e3o para o rob\u00f4 baseado no EV3, destacando as principais diferen\u00e7as e adapta\u00e7\u00f5es necess\u00e1rias em rela\u00e7\u00e3o ao NXT.</p> <p>Pontos importantes a serem considerados durante a migra\u00e7\u00e3o:</p> <ul> <li>Certifique-se de seguir as instru\u00e7\u00f5es de configura\u00e7\u00e3o do EV3 na se\u00e7\u00e3o Setup do EV3.</li> <li>O SDK para o EV3 \u00e9 diferente do NXT, ent\u00e3o voc\u00ea precisar\u00e1 adaptar seu c\u00f3digo para usar as bibliotecas e APIs espec\u00edficas do EV3. Enquanto o NXT usa uma API procedural baseada em C, o EV3 \u00e9 100% baseado em C++11 e orientado a objetos.</li> <li>O RobotC roda como um firmware no NXT, enquanto o EV3DEV C++ roda como um programa de usu\u00e1rio no EV3, que possui um sistema operacional Linux completo (baseado em Debian). Isso afeta como a intera\u00e7\u00e3o com o hardware e o sistema \u00e9 realizada: O hardware \u00e9 exposto como arquivos na pasta <code>/sys/class</code>, e a comunica\u00e7\u00e3o com sensores e atuadores \u00e9 feita atrav\u00e9s da leitura e escrita nesses arquivos.</li> </ul> <p>Essa documenta\u00e7\u00e3o ainda est\u00e1 em desenvolvimento e ainda n\u00e3o cobre todos os aspectos da migra\u00e7\u00e3o, at\u00e9 o momento h\u00e1 essas interfaces:</p> <ul> <li>Motores.</li> <li>Sensores.</li> <li>LCD.</li> </ul>"},{"location":"migracao-ev3/lcd/","title":"Migra\u00e7\u00e3o do LCD","text":"<p>Esta se\u00e7\u00e3o aborda a migra\u00e7\u00e3o do c\u00f3digo relacionado ao LCD do NXT para o EV3.</p>"},{"location":"migracao-ev3/lcd/#diferencas-principais","title":"Diferen\u00e7as Principais","text":"<p>No RobotC, o LCD do NXT \u00e9 acessado atrav\u00e9s de fun\u00e7\u00f5es espec\u00edficas, como <code>nxtDisplayString()</code> para exibir texto e <code>nxtDrawLine()</code> para desenhar linhas. Essas fun\u00e7\u00f5es s\u00e3o diretas e utilizam coordenadas simples para posicionamento.</p> <p>No EV3 temos duas op\u00e7\u00f5es, printar na tela pelo serial padr\u00e3o, ou modificar o LCD. O LCD  \u00e9 manipulado atrav\u00e9s de um framebuffer, que \u00e9 uma representa\u00e7\u00e3o em mem\u00f3ria da tela.</p>"},{"location":"migracao-ev3/lcd/#printar-no-serial-padrao","title":"Printar no Serial Padr\u00e3o","text":"<p>No EV3, voc\u00ea pode usar a sa\u00edda padr\u00e3o para imprimir texto na tela do LCD. Isso \u00e9 feito utilizando as fun\u00e7\u00f5es padr\u00e3o de C++ como <code>std::cout</code>. Aqui est\u00e1 um exemplo simples:</p> <pre><code>#include &lt;iostream&gt;\n#include \"ev3dev.h\"\nusing namespace ev3dev;\nint main() {\n    std::cout &lt;&lt; \"Hello, EV3!\" &lt;&lt; std::endl;\n    return 0;\n}\n</code></pre> <p>Essa maneira \u00e9 mais simples e recomendada para a maioria dos casos, especialmente para depura\u00e7\u00e3o e mensagens simples.</p>"},{"location":"migracao-ev3/lcd/#framebuffer-no-ev3","title":"Framebuffer no EV3","text":"<p>O framebuffer \u00e9 a camada abaixo disso. \u00c9 o m\u00e9todo de mais baixo n\u00edvel (sem ser o driver do kernel) que o Linux usa para desenhar na tela.</p> <p>\u00c9 uma abordagem mais complexa, mas oferece controle total sobre cada pixel na tela.</p>"},{"location":"migracao-ev3/lcd/#o-que-e-o-framebuffer","title":"O Que \u00e9 o Framebuffer?","text":"<p>Pense no framebuffer como um grande mapa de bits (bitmap) na RAM que representa diretamente cada pixel da tela.</p> <ul> <li>\u00c9 um buffer (um peda\u00e7o de mem\u00f3ria) cont\u00ednuo.</li> <li>Cada c\u00e9lula nesse buffer corresponde a um pixel (ou um conjunto de pixels).</li> <li>O hardware de v\u00eddeo do EV3 est\u00e1 configurado para, constantemente, ler essa \u00e1rea da mem\u00f3ria e exibi-la na tela.</li> <li>Se voc\u00ea escrever dados diretamente nessa \u00e1rea da mem\u00f3ria, a imagem na tela muda instantaneamente (no pr\u00f3ximo ciclo de atualiza\u00e7\u00e3o).</li> </ul> <p>No EV3, o framebuffer \u00e9 de 176x128 pixels, com 1 bit por pixel (preto e branco).</p>"},{"location":"migracao-ev3/lcd/#como-usar-o-framebuffer","title":"Como Usar o Framebuffer","text":"<p>Para manipular o framebuffer diretamente, voc\u00ea pode abrir o dispositivo <code>/dev/fb0</code> e escrever dados nele. Aqui est\u00e1 um exemplo b\u00e1sico de como fazer isso:</p> <pre><code>#include \"ev3dev.h\"\n#include &lt;fcntl.h&gt;\n#include &lt;unistd.h&gt;\n#include &lt;sys/mman.h&gt;\n#include &lt;linux/fb.h&gt;\n#include &lt;sys/ioctl.h&gt;\n#include &lt;iostream&gt;\n\nbool set_console_bind(bool bind) \n{\n    // O arquivo de controle pode ser vtcon0 ou vtcon1.\n    // No ev3dev, geralmente \u00e9 o vtcon0.\n    std::ofstream f(\"/sys/class/vtconsole/vtcon0/bind\");\n    if (!f.is_open()) {\n        // Tenta o vtcon1 como fallback\n        f.open(\"/sys/class/vtconsole/vtcon1/bind\");\n    }\n    if (!f.is_open()) {\n        std::cerr &lt;&lt; \"Erro: Nao foi possivel abrir /sys/class/vtconsole/...\" &lt;&lt; std::endl;\n        return false;\n    }\n    // Escreve \"0\" para desvincular ou \"1\" para vincular\n    f &lt;&lt; (bind ? \"1\" : \"0\");\n    f.close();\n    return true;\n}\n\nint main()\n{\n    // --- 1. Abrir o Framebuffer ---\n    int fb_fd = open(\"/dev/fb0\", O_RDWR);\n    if (fb_fd == -1) { /* erro */ }\n    if (!set_console_bind(false)) {\n        return 1; // Falha\n    }\n    // --- 2. Obter informa\u00e7\u00f5es da tela (ESPECIALMENTE o line_length) ---\n    fb_fix_screeninfo finfo;\n    if (ioctl(fb_fd, FBIOGET_FSCREENINFO, &amp;finfo) == -1) {\n        // finfo.line_length nos dir\u00e1 o \"stride\" (provavelmente 24 bytes)\n        /* erro */\n    }\n    long screen_size_bytes = finfo.smem_len; // Tamanho total do buffer\n    int line_length_bytes = finfo.line_length; // \"Stride\" (bytes por linha)\n    // --- 3. Mapear para a Mem\u00f3ria ---\n    unsigned char* fb_ptr = (unsigned char*)mmap(\n        0, \n        screen_size_bytes, \n        PROT_READ | PROT_WRITE, \n        MAP_SHARED, \n        fb_fd, \n        0\n    );\n    if (fb_ptr == (void*)-1) { /* erro */ }\n    // --- 4. Desenhar! ---\n    // Limpar a tela (definir todos os bytes como 0x00 = branco)\n    memset(fb_ptr, 0x00, screen_size_bytes);\n    // Desenhar um pixel em (x=10, y=5)\n    int x = 10;\n    int y = 5;\n    // Calcular o endere\u00e7o do byte\n    // Pula 'y' linhas (cada uma com 'line_length_bytes')\n    // e avan\u00e7a 'x / 8' bytes na linha atual\n    unsigned char* byte_ptr = fb_ptr + (y * line_length_bytes) + (x / 8);\n    // Calcular o bit dentro desse byte\n    // (o bit 0 \u00e9 o mais \u00e0 esquerda, ou o mais \u00e0 direita? \n    // No EV3, \u00e9 little-endian, ent\u00e3o o bit 0 \u00e9 o da direita)\n    int bit_index = x % 8;\n    // Ligar o pixel (preto)\n    *byte_ptr |= (1 &lt;&lt; bit_index);\n    // Esperar um pouco para ver\n    std::this_thread::sleep_for(std::chrono::seconds(5));\n    // --- 5. Limpar ---\n    munmap(fb_ptr, screen_size_bytes);\n    close(fb_fd);\n    // Lembre-se de reativar o console se voc\u00ea o desligou!\n    set_console_bind(true);\n    return 0;\n}\n</code></pre>"},{"location":"migracao-ev3/motores/","title":"Migra\u00e7\u00e3o dos Motores","text":"<p>Esta se\u00e7\u00e3o aborda a migra\u00e7\u00e3o do c\u00f3digo relacionado aos motores do NXT para o EV3.</p>"},{"location":"migracao-ev3/motores/#diferencas-principais","title":"Diferen\u00e7as Principais","text":"<p>No RobotC, os motores s\u00e3o acessados diretamente atrav\u00e9s de arrays pr\u00e9-definidos, como <code>motor[]</code>, onde cada \u00edndice corresponde a uma porta espec\u00edfica do motor. Por exemplo, <code>motor[motorA]</code> acessa o motor conectado \u00e0 porta A. </p> <p>J\u00e1 no EV3, os motores s\u00e3o representados como objetos de classes espec\u00edficas, como <code>ev3dev::motor::large_motor</code> ou <code>ev3dev::motor::medium_motor</code>. Cada motor \u00e9 instanciado com base na porta \u00e0 qual est\u00e1 conectado, utilizando a nomenclatura do sistema de arquivos do Linux. Al\u00e9m disso, o motor n\u00e3o \u00e9 controlado diretamente por valores num\u00e9ricos, mas sim m\u00e9todos que definem comportamentos espec\u00edficos, como velocidade, posi\u00e7\u00e3o, etc.</p>"},{"location":"migracao-ev3/motores/#tabela-de-equivalencias","title":"Tabela de Equival\u00eancias","text":"A\u00e7\u00e3o NXT EV3 Girar Continuamente <code>motor[motorA] = 50;</code> <code>large_motor motorA(\"outA\"); motorA.set_speed_sp(500); motorA.run_forever();</code> Parar Motor <code>motor[motorA] = 0;</code> <code>motorA.stop();</code> Ler Enconder <code>long valor = nMotorEncoder[motorA];</code> <code>int valor = motorA.position();</code> Redefinir Encoder <code>nMotorEncoder[motorA] = 0;</code> <code>motorA.set_position(0);</code>"},{"location":"migracao-ev3/motores/#exemplo-de-codigo","title":"Exemplo de C\u00f3digo","text":""},{"location":"migracao-ev3/motores/#nxt-robotc","title":"NXT (RobotC)","text":"<pre><code>task main() {\n    // Girar motor A a 50% de pot\u00eancia\n    motor[motorA] = 50;\n    wait1Msec(2000); // Espera por 2 segundos\n    // Parar o motor\n    motor[motorA] = 0;\n    // Ler o valor do encoder\n    long valor = nMotorEncoder[motorA];\n    // Redefinir o encoder\n    nMotorEncoder[motorA] = 0;\n}\n</code></pre>"},{"location":"migracao-ev3/motores/#equivalente-ev3-ev3dev-c","title":"Equivalente EV3 (EV3DEV C++)","text":"<pre><code>#include \"ev3dev.h\"\n#include &lt;thread&gt;\n#include &lt;chrono&gt;\n\nusing namespace ev3dev;\n\nint main() {\n  // 1. Instanciar o motor na porta B\n  motor motor_b(OUTPUT_B);\n  // 2. Definir velocidade (ex: 450 graus/seg)\n  motor_b.set_speed_sp(450);\n  // 3. Ligar o motor\n  motor_b.run_forever();\n  // 4. Esperar 2 segundos (usando C++ moderno)\n  std::this_thread::sleep_for(std::chrono::seconds(2));\n  // 5. Parar o motor\n  motor_b.stop();\n  return 0;\n}\n</code></pre>"},{"location":"migracao-ev3/sensores/","title":"Migra\u00e7\u00e3o dos Sensores","text":""},{"location":"migracao-ev3/sensores/#diferencas-principais","title":"Diferen\u00e7as Principais","text":"<p>Assim como os motores, os sensores no NXT s\u00e3o acessados diretamente atrav\u00e9s de arrays pr\u00e9-definidos, como <code>SensorValue[]</code>, onde cada \u00edndice corresponde a uma porta espec\u00edfica do sensor. Por exemplo, <code>SensorValue[S1]</code> acessa o sensor conectado \u00e0 porta 1.</p> <p>No EV3, os sensores s\u00e3o representados como objetos de classes espec\u00edficas, como <code>ev3dev::sensor::color_sensor</code> ou <code>ev3dev::sensor::ultrasonic_sensor</code>. Cada sensor \u00e9 instanciado com base na porta \u00e0 qual est\u00e1 conectado, utilizando a nomenclatura do sistema de arquivos do Linux. A leitura dos valores dos sensores \u00e9 feita atrav\u00e9s de m\u00e9todos espec\u00edficos dessas classes.</p>"},{"location":"migracao-ev3/sensores/#tabela-de-equivalencias","title":"Tabela de Equival\u00eancias","text":"A\u00e7\u00e3o NXT EV3 Ler Valor do Sensor Ultrass\u00f4nico <code>SensorType[S2] = sensorSONAR; int dist = SensorValue[S2]; // Em cm</code> <code>ultrasonic_sensor us(INPUT_2); int dist = us.distance_centimeters();</code> Ler Valor do Sensor de Cor <code>SensorType[S3] = sensorCOLORFULL; int color = SensorValue[S3];</code> <code>color_sensor cs(INPUT_3); int color = cs.color();</code> Configurar Sensor de Toque <code>SensorType[S1] = sensorEV3_TOUCH;</code> <code>touch_sensor ts(INPUT_1);</code>"},{"location":"migracao-ev3/sensores/#exemplo-de-codigo","title":"Exemplo de C\u00f3digo","text":""},{"location":"migracao-ev3/sensores/#nxt-robotc","title":"NXT (RobotC)","text":"<pre><code>task main()\n{\n  SensorType[S1] = sensorTouch;\n  while(SensorValue[S1] == 0)\n  {\n    // Espera\n  }\n  // Pressionado\n}\n</code></pre>"},{"location":"migracao-ev3/sensores/#equivalente-ev3-ev3dev-c","title":"Equivalente EV3 (EV3DEV C++)","text":"<pre><code>#include \"ev3dev.h\"\n\nusing namespace ev3dev;\n\nint main()\n{\n  // 1. Instanciar o sensor de toque na porta 1\n  touch_sensor ts(INPUT_1);\n  // 2. Esperar em um loop enquanto n\u00e3o estiver pressionado\n  while( !ts.is_pressed() )\n  {\n    // \u00c9 uma boa pr\u00e1tica esperar um pouco em loops\n    std::this_thread::sleep_for(std::chrono::milliseconds(10));\n  } \n  // Pressionado\n  return 0;\n}\n</code></pre>"}]}